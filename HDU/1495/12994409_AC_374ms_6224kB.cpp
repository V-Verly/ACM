#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
struct cup{
int a,b,c,step;
};
int vis[105][105][105];
void BFS(int a,int b,int c)
{
    cup r;
    r.a=a;
    r.b=0;
    r.c=0;
    r.step=0;
    vis[a][0][0]=1;
    queue <cup> que;
    que.push(r);
    int flag=1;
    while(!que.empty())
    {
        cup k=que.front();
        que.pop();
        if((k.a==a/2&&k.b==a/2)||(k.a==a/2&&k.c==a/2)||(k.b==a/2&&k.c==a/2))
        {
            printf("%d\n",k.step);
            flag=0;
            break;
        }
        if(k.a)
        {
            if(k.a>b-k.b)
            {
                r.a=k.a-b+k.b;
                r.b=b;
                r.c=k.c;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            else
            {
                r.a=0;
                r.b=k.b+k.a;
                r.c=k.c;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            if(k.a>c-k.c)
            {
                r.a=k.a-c+k.c;
                r.c=c;
                r.b=k.b;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            else
            {
                r.a=0;
                r.c=k.c+k.a;
                r.b=k.b;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
        }
        if(k.b)
        {
            if(k.b>a-k.a)
            {
                r.b=k.b-a+k.a;
                r.a=a;
                r.c=k.c;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            else
            {
                r.a=k.a+k.b;
                r.b=0;
                r.c=k.c;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            if(k.b>c-k.c)
            {
                r.b=k.b-c+k.c;
                r.a=k.a;
                r.c=c;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            else
            {
                r.c=k.c+k.b;
                r.b=0;
                r.a=k.a;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
        }
        if(k.c)
        {
            if(k.c>a-k.a)
            {
                r.c=k.c-a+k.a;
                r.a=a;
                r.b=k.b;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            else
            {
                r.a=k.a+k.c;
                r.c=0;
                r.b=k.b;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            if(k.c>b-k.b)
            {
                r.c=k.c-b+k.b;
                r.a=k.a;
                r.b=b;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
            else
            {
                r.b=k.b+k.c;
                r.c=0;
                r.a=k.a;
                r.step=k.step+1;
                if(!vis[r.a][r.b][r.c])
                {
                    vis[r.a][r.b][r.c]=1;
                    que.push(r);
                }
            }
        }
    }
    if(flag) printf("NO\n");
}
int main()
{
    int s,n,m;
    while(scanf("%d%d%d",&s,&n,&m)!=EOF&&(s||n||m))
    {
        if(s%2) printf("NO\n");
        else
        {
            memset(vis,0,sizeof(vis));
            BFS(s,n,m);
        }
    }
    return 0;
}
